--- Relational Manager ---
This aspect of the project handles the file management for all the tables.  This portion highly relies on the catalog (or system tables) of the project.  These
tables are defined as system tables by an each Table record having an additional attribute (table-type) which if the value is 0 then is a user table.  If 1, then is
a system table.  For most comparisons when making edits to a potential system table, the comparison ensures that the value must equal 0 to continue on, this prevents
if any hazardous bugs occured, no data corruption occurs.  

CreateCatalog simply initializes the descriptors of these 2 tables then stores them in memory for quickly access, instead of using IO.  It also uses a special
function called CreateSystemTable which is the only function that has the ability to initialize a table record as a system table.  CreateTable only has the
ability to set the record to 0.  

Any tuple function (delete/update/insert) will test to make sure they are not being used on any system table.  Any function that must insert into the catalog will rely
on using the lower layer functions to do this.

For the most part, all CRUD functions will rely on the same basic operations
	- Scan through tables and get the file-name and table-type
	- Ensure that table-type is not 1
	- Open a file handle to file name
	- Get the descriptor from getAttributes (columns table)
	- Run that lower layer CRUD function using the descriptor and file handle
	- Then close the file handle.

--- Record Based File Manager ---
The RBFM now supports Update/Delete
With the addition of update and delete, our system needs a strong system to handle what to do with this memory.
Here are some definitions:
	- Tombstone -- Is when a record has been completely deleted.
	- Pointer -- Is when a record was updated, now does not fit on the current page, and is placed on another page.  This (pointer) will be used to describe where this record now currently lies.
	A pointer works as such. In the slot directory, we key a pair of values <offset, length>.  When the slot is not a pointer length will be greater than 0, because a record should at least contain a nullIndicator.
	A pointer is a pointer, when both length and offset are negative.  These negative values mean <page, slot>.  To get these values, we unnegate them and -1.  This is to fix if we moved a record to page 0 slot 0.

Delete pattern is as such:
	- Load the correct page
	- It will then using the rid and page, get the offset and length of the record
	- If length is negative; return DeleteRecord with new RID extracted from the slot.
	- Replace all that data with 0
	- Empty slot information
	- Compact the memory from the removal
	- Write the page.

Update pattern is as such:
	- Delete the record
	- Get the new offset and potentially the new RID.
	- Determine new free space
	- if length > freeSpace, insert the record with the negated version of this RID
	- else insert as normal.

The great thing about this update pattern is the chain of tombstones will never be larger than 1. Because everytime you make an update to a record, it will always delete it first.  This reduces the posibility of 
having to iterate over the N possible pages to get a record from the DB.
